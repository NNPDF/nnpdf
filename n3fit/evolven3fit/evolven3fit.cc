// $Id$
//
// NNPDF++ 2016
//
// Authors: Nathan Hartland,  n.p.hartland@ed.ac.uk
//          Stefano Carrazza, stefano.carrazza@mi.infn.it

#include <string>
#include <iomanip>
#include "common.h"
#include "nnpdfsettings.h"
#include "exportgrid.h"
#include "evolgrid.h"
#include <sys/stat.h>
using namespace NNPDF;
using std::cout;
using std::endl;
using std::cerr;
using std::string;
using std::stoi;

// Check if folder exists
bool CheckConsistency(string const& folder, string const& exportfile)
{
  bool status1 = false, status2 = false;
  struct stat s, t;
  if (stat(folder.c_str(), &s) == 0)
    if (s.st_mode & S_IFDIR)
        status1 = true;
  if (stat(exportfile.c_str(), &t) == 0)
    if (t.st_mode)
      status2 = true;
  if (status1 == true && status2 == true) return true;
  else return false;
}

/**
 * This program:
 * - takes as input a fit folder and a theoryID,
 * - loads a vector of ExportGrid for all replicas generated by nnfit,
 * - computes the DGLAP evolution operators for the theoryID
 * - applies the evolution operators to the ExportGrid objects
 * - outputs the evolved PDFs in the LHAPDF format to the fit folder.
 */
int main(int argc, char **argv)
{
  // Read configuration filename from arguments
  if (argc != 3)
    {
      cerr << Colour::FG_RED << "\nusage: evolven3fit [configuration folder] [max_replicas]\n" << Colour::FG_DEFAULT << endl;
      exit(EXIT_FAILURE);
    }

  const string fit_path = argv[1];
  const int maxreplica = stoi(argv[2]);

  // load settings from config folder
  NNPDFSettings settings(fit_path);
  const int theory_id = settings.Get("theory","theoryid").as<int>();

  // load theory from db
  std::map<string,string> theory_map;
  NNPDF::IndexDB db(get_data_path() + "/theory.db", "theoryIndex");
  db.ExtractMap(theory_id, APFEL::kValues, theory_map);
  
  // load grids
  vector<ExportGrid> initialscale_grids;
  vector<int> replicas;
  for (int nrep = 1; nrep <= maxreplica; nrep++)
    {
      const string folder = fit_path + "/nnfit/replica_" + std::to_string(nrep);
      const string path = folder + "/" + settings.GetPDFName() + ".exportgrid";
      bool status = CheckConsistency(folder, path);
      if (status)
        {
          initialscale_grids.emplace_back(path);
          replicas.push_back(nrep);
        }
      else
        {
          cout << "Skipping exportgrid (missing file): " << path << endl;
        }
    }
  
  if (initialscale_grids.size() == 0)
      throw NNPDF::RuntimeException("main", "nrep = 0, check replica folder/files.");

  string infofile = fit_path + "/nnfit/" + settings.GetPDFName() + ".info";
  auto dglapg = EvolveGrid(initialscale_grids, theory_map);
  dglapg.WriteInfoFile(infofile);

  const auto outstream = dglapg.WriteLHAFile();
  for (size_t i = 0; i < outstream.size(); i++)
    {
      stringstream replica_file;
      replica_file << fit_path
                   << "/nnfit/replica_"
                   << replicas[i] 
                   << "/"
                   << settings.GetPDFName()
                   << ".dat";
      write_to_file(replica_file.str(), outstream[i].str());
    }    

  return 0;
}
